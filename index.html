<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Roll Six Win</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100vh;
  background-color: #004d00;
  color: #fff;
}
.board-text {
  text-align: center;
  font-weight: 700;
  font-family: 'Times New Roman', Times, serif;
  color: rgb(134, 214, 138);
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.327), 2px 2px 1px 1px rgba(0, 0, 0, 0.37);
  padding: 5px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  flex-shrink: 0; /* Prevent shrinking */
  cursor: default;
}

nav {
  width: 100vw;
  display: flex;
  align-items: center;
  justify-content: space-between;
  user-select: none;
}
.board-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  align-items: center;
  margin-top: 50px;
  border: 5px solid black;
  width: auto;
  height: auto;
  user-select: none;
  padding: 10px;

}

.betting-board {
  width: 200px;
  height: 200px;
  border: 1px solid black;
  border-radius: none;
  margin: 8px;
  padding: 30px;
  position: relative;
  background-color: #006400;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  transition: box-shadow 0.3s;
  text-align: center;
  font-size: 1.5em;
  cursor: default;
}
.betting-board.active {
  animation: winner .1s infinite;
}

.betting-board:hover {
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
}
.chips-container {
  border: 5px solid rgb(104, 104, 104);
  padding: 10px;
  border-radius: 9%;
  background: gray;
  box-shadow: inset  5px 5px 5px 5px rgba(0, 0, 0, 0.274);
}
@keyframes drop {
  0% {
    bottom: -20px;
    opacity: 1;
    transform: translateY(-40%) scale(0.95);
  }
  40% {
    opacity: 1;
    transform: translateY(-44%) scale(1);
  }
  80% {
    opacity: 1;
    transform: translateY(-48%) scale(0.95);
  }
  100% {
    bottom: 0;
    opacity: 1;
    transform: translateY(-50%) scale(1);
  }
}
@keyframes rotate-0 {
  0% {
    transform: translateY(-50%) scale(1) rotate(0deg);
  }
  100% {
    transform: translateY(-50%) scale(1) rotate(0deg);
  }
}

@keyframes rotate-45 {
  0% {
    transform: translateY(-50%) scale(1) rotate(0deg);
  }
  100% {
    transform: translateY(-50%) scale(1) rotate(15deg);
  }
}

@keyframes rotate-90 {
  0% {
    transform: translateY(-50%) scale(1) rotate(0deg);
  }
  100% {
    transform: translateY(-50%) scale(1) rotate(30deg);
  }
}

/* Define more keyframes rules with different rotation angles as needed */

.chip {
  position: relative;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background-color: #0b4b45; /* Dark teal background */
  border: 4px solid rgba(220, 220, 220, 0.75); /* Light border */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 18px; /* Larger font size */
  color: #fff;
  text-align: center;
  cursor: pointer; /* Reverting to pointer cursor */
  transition: transform 0.2s ease-in-out;
}
.chip:hover {
  transform: scale(1.1); /* Slightly increase size on hover */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}
.chip.disabled {
  opacity: 0.1; /* Example: reduce opacity for disabled chips */
  pointer-events: none; /* Prevent interactions with disabled chips */
  /* Add any additional styling for disabled chips */
}
.hovered {
  border: 1px solid rgba(255, 217, 0, 0.2);
}
.chip .center-circle {
  width: 30px;
  height: 30px;
  background-color: #fff; /* White center circle */
  background-image: url('./polygon.chip.webp');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover; /* or */
  border-radius: 50%;
  border: 3px solid rgba(125, 0, 183, 0.356); /* Teal border */
  display: flex;
  justify-content: center;
  align-items: center;
  color: #0b4b45; /* Dark teal text color */
  font-weight: bold;
  font-size: 24px;
  position: relative;
  z-index: 2;
}
.center-circle::before {
    content: ''; /* Required for pseudo-elements */
    position: absolute;
    border-radius: 50%;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to top left,rgba(251, 255, 0, 0.2),rgba(255, 255, 255, 0.1) );
}
.chip .center-circle.value {
  position: absolute;
  display: none;
}
.chip:hover .center-circle.value {
  display: flex;
  font-size: 17px;
  background-color: rgb(255, 255, 255);
  background-image: none;
}
/* .numbered-board.waiting {
  transition: background 1s ease;
  animation: waiting 1s ease infinite;
}
@keyframes waiting {
  0% {
    background: #000000;
  }
  100% {
    background: #fff;
  }
} */

.red::before, .black::before {
  transition: background 2s ease, transform 2s ease;
  content: attr(data-value);
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 50px;
  height: 50px;
  border-radius: 50%;
  font-family: Helvetica, sans-serif;
}
.waiting::before{
  content: attr(data-value);
  display: flex;
  justify-content: center;
  align-items: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 50px;
  height: 50px;
  border-radius: 50%;
  font-family: Helvetica, sans-serif;
  background: rgba(255, 255, 255, 0.393);
}

.red::before {
  background: linear-gradient(to top left, rgba(255, 255, 255, 0.5), rgba(255, 0, 0, 1));
}

.black::before {
  background: linear-gradient(to top left, rgba(255, 255, 255, 0.5), rgba(0, 0, 0, 1));
}

#chips {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 20px;
}

.active {
  display: block !important;
}
#account-button,
#deposit-button {
  display: none;
}

.nav-button {
  background: linear-gradient(135deg, #0c6b0c, #009900);
  color: white;
  font-weight: 700;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  font-family: 'Times New Roman', Times, serif;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  cursor: pointer;
  user-select: none;
  

}
.nav-button:hover {
  animation: pulse-two .93s;
}

#place-bet-button {
  position: absolute;
  right: 15px;
  bottom: 30px;
}
#wallet-status-container {
  width: 119px;
  height: 25px;
  border-radius: 10px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  max-width: 600px;
  background-color: rgba(0, 0, 0, 0.2);
  margin-left: 15px;
}
#wallet-status-container:hover {
  width: auto;
}
#stats-container {
  padding-top: 15px;
  padding-right: 15px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap; /* Enable wrapping */
  gap: 20px; /* Space between balance and round */
}

.stat-item {
  text-align: center;
  min-width: 100px; /* Adjust width to ensure proper wrapping */
  flex: 1; /* Ensure items take available space */
}
.stat-item:last-child {
  display: flex; /* Make the last item a flex container */
  flex-direction: column; /* Stack items vertically */
  justify-content: center; /* Center items vertically */
  align-items: center; /* Center items horizontally */
  text-align: center; /* Center text inside */
  flex-basis: 100%; /* Force the last item to take a new row */
}


.stat-item p {
  margin: 0;
  margin-top: 15px;
}

.board-value {
  height: 15px;
  width: auto;
  padding: 15px;
  font-weight: 700;
  color: rgb(255, 255, 0);
  font-family: monospace;
  font-size: 1rem;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.327), 2px 2px 1px 1px rgba(0, 0, 0, 0.37);
}


.broke {
  animation: pulse 1.9s infinite linear;
  animation-fill-mode: forwards;
}
#log-status-indicator {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(145deg, #ff5f5f, #d9534f);
  color: white;
  font-size: 20px;
  margin-right: 5px;
}
.logged-in {
  background: linear-gradient(145deg, #b8ff80, #98e664) !important;
}

/* Adding a smooth shadow effect for a more professional feel */
#log-status-indicator::after {
  border-radius: 50%;
  box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.2), inset -2px -2px 4px rgba(255, 255, 255, 0.2);
  transition: box-shadow 0.45s ease;
}

#wallet-address {
  font-size: 12px;
  letter-spacing: 2px;
  color: #ffffffb7;
  font-family: Arial, sans-serif;
  text-align: left;
  cursor: default;
  overflow: hidden;
  white-space: nowrap;
  user-select: all;
}
#connect-wallet-button:hover {
animation: pulse-two .93s;
}
#account {
  width: 150px;
  margin-left: 15px;
}
@keyframes increase {
  0% {
    color: rgb(255, 255, 0);
  }
  25% {
    color: rgb(100, 255, 0);
    text-shadow: 10px 10px 20px rgba(100, 255, 0, .15);
  }
  50% {
    color: rgb(0, 255, 0);
    text-shadow: 10px 10px 20px rgba(100, 255, 0, .1);
  }
  75% {
    color: rgb(100, 255, 0);
    text-shadow: 10px 10px 20px rgba(100, 255, 0, .05);
  }
  100% {
    color: rgb(255, 255, 0);
  }
}
@keyframes decrease {
  0% {
    color: rgb(255, 255, 0);
  }
  25% {
    color: rgb(255, 100, 0);
    text-shadow: 10px 10px 20px rgba(238, 255, 0, 0.15);
  }
  50% {
    color: rgb(255, 0, 0);
    text-shadow: 10px 10px 20px rgba(229, 255, 0, 0.1);
  }
  75% {
    color: rgb(255, 100, 0);
    text-shadow: 10px 10px 20px rgba(234, 255, 0, 0.05);
  }
  100% {
    color: rgb(255, 255, 0);
  }
}
@keyframes pulse {
  0% {
    /* transform: scale(1); */
    box-shadow: 0 0 0 0 rgba(254, 93, 82, 0.7);
  }
  50% {
    /* transform: scale(1.05); */
    box-shadow: 0 0 0 10px rgba(255, 184, 184, 0);
  }
  100% {
    /* transform: scale(1); */
    box-shadow: 0 0 0 0 rgba(0, 0, 0, 0);
  }
}
@keyframes pulse-two {
  0% {
    /* transform: scale(1); */
    box-shadow: 0 0 0 0 rgba(82, 254, 82, 0.2);
  }
  50% {
    /* transform: scale(1.05); */
    box-shadow: 0 0 0 8px rgba(255, 184, 184, 0);
  }
  100% {
    /* transform: scale(1); */
    box-shadow: 0 0 0 0 rgba(0, 0, 0, 0);
  }
}
.pulse-class {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  animation: pulse 1s linear;
  animation-fill-mode: forwards;
}
.pulse-two-class {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  animation: pulse-two 1s linear;
  animation-fill-mode: forwards;
}

.hidden {
  display: none;
}

#lossParticles {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  z-index: 1000;
}
#breakEven {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  z-index: 1000;
}

#loseMessage {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: red;
  font-weight: bold;
  opacity: 0;
  transition: font-size 2s, opacity 2s;
  z-index: 1;
}
#loseMessage.show {
  opacity: 1;
  font-size: 3rem;
}
#breakEvenMessage {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: rgb(255, 255, 255);
  font-weight: bold;
  opacity: 0;
  transition: font-size 2s, opacity 2s;
  z-index: 1;
}

#breakEvenMessage.show {
  opacity: 1;
  font-size: 3rem;
}
#winMessage {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5rem;
  color: rgb(26, 255, 0);
  font-weight: bold;
  opacity: 0;
  transition: font-size 2s, opacity 2s;
  z-index: 1;
}

#winMessage.show {
  opacity: 1;
  font-size: 3rem;
}
.fade-in-out {
    transition: opacity 0.15s ease-in, transform 0.15s ease, font-size 0.15s ease, color .15s ease;
  }

  .fade-in-out.hidden2 {
    opacity: .75;
    font-size: .93rem !important;
  }
  .fade-in-out.increase {
    animation: increase 0.25s linear;
    color: rgb(255, 255, 0);
    animation-fill-mode: forwards;
  }
  .fade-in-out.decrease {
    animation: decrease 0.25s linear;
    color: rgb(255, 255, 0);
    animation-fill-mode: forwards;
  }

  .fade-in-out.hidden3 {
    opacity: .75;
    font-size: .93rem !important;
  }


   /* Win display styles */
   #winsDisplay {
   background-color: #2d53374d;
    border: none;
    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.327), 2px 2px 1px 1px rgba(0, 0, 0, 0.37);
    border-radius: 10%;
    margin: 10px 20px; /* Adjusted margin for spacing */
    max-width: 100%; /* Full width */
    padding: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Soft shadow */
    height: 60px; /* Adjusted height */
    overflow: hidden; /* Hide overflow if content exceeds height */
    display: flex;
    justify-content: space-around;
    align-items: center;
    user-select: none;
  }

  .win-item {
    display: flex;
    align-items: center;
  }

  .win-text {
    font-size: .99rem;
    margin-right: 5px;
    outline: none;
  }

  .win-multiplier {
    position: absolute;
    display: flex;
    justify-content: center;
    align-content: center;
    top: 50%;
    right: 50%;
    bottom: 50%;
    left: 50%;
    scale: 1;
    font-size: .95rem;
    font-weight: 700;
    opacity: .75;
    scale: 1;
    animation: multiplier-animation 5s ease infinite;
    animation-fill-mode: forwards;
  }
  @keyframes multiplier-animation {
    0% {
      scale: 1;
      opacity: .5;
      color: rgb(192, 255, 203) ;
    } 
    25% {
      scale: 1.35;
      opacity: 1;
      color: rgb(0, 255, 0) ;
    }
    50% {
      scale: 1;
      opacity: .5;
      color: rgb(192, 255, 203);
    }
    75% {
      scale: .95;
      opacity: .25;
      color: rgb(152, 255, 169) ;
    }
    100% {
      scale: 1;
      opacity: .5;
      color: rgb(192, 255, 203);
    }

  }
  .lights {
    display: flex;
    justify-content: flex-start; /* Align lights to the left */
  }

  .numbered-board.active {
    animation: winner .2s infinite;
  }

  @keyframes winner {
    0% {
      box-shadow:inset 2px 2px 1px rgba(251, 251, 251, 0.2);
      border: 1.25px solid white;
    }
    25% {
      box-shadow: inset 2px 2px 4px rgba(185, 255, 203, 0.3);
      border: 1.25px solid white;
    }
    50% {
      box-shadow: inset 2px 2px 8px rgba(175, 255, 182, 0.4);
      border: 1.25px solid white;
    }
    75% {
      box-shadow: inset 2px 2px 4px rgba(185, 255, 203, 0.3);
      border: 1.25px solid white;
    }
    100% {
      box-shadow: inset 2px 2px 1px rgba(255, 255, 255, 0.2);
      border: 1.25px solid white;
    }
  }
  .light {
    color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #006400;
    margin: 0 2px;
    font-size: 1rem;
    font-weight: 700;
    font-family: monospace;
    padding: 10px;
    letter-spacing: -1.5px;
  }
.placed {
  transform: translateX(-50%);
  animation: drop .33s ease-out forwards;
  scale: .8;
}
  .light.on {
    background-color: rgba(255, 255, 0, 0.5); /* Yellowish light on color */
    color: #333; /* Dark text color */
  }
  .streaks {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin: 0 5px;
  }
  #parity-streaks {
    background-color: rgb(0, 151, 0) ;
  }
  .parity-streaks {
    background-color: rgb(0, 151, 0)  ;
  }
  #number-streaks {
    background-color: rgb(0, 100, 0) ;

  }
  .number-streaks {
    border-radius: 5px;
  }
#color-streaks {
  background-color: rgb(0, 49, 0) ;
}
.color-streaks {
  background-color:#005a00;
}


.chip-0_1 {
  background: linear-gradient(45deg, rgba(177, 207, 67, 1), rgba(255, 255, 0, 1));
}

.chip-0_25 {
  background: linear-gradient(45deg, rgba(0, 191, 255, 1), rgba(0, 255, 255, 1));
}

.chip-0_5 {
  background: linear-gradient(45deg, rgba(50, 205, 50, 1), rgba(0, 255, 0, 1));
}

.chip-1 {
  background: linear-gradient(45deg, rgba(204, 0, 255, 1), rgba(255, 0, 255, 1));
}

.chip-default {
  background: linear-gradient(45deg, rgba(11, 75, 69, 1), rgba(255, 255, 255, 1));
}
#history-display {
  text-decoration: none;
  display: flex;
  flex-direction: row;
  width: 300px;
  justify-content: center;
  align-items: center;
  border: 1px solid rgb(0, 255, 89);
  background-color: #008f1f;
  color: black;
  overflow-x: scroll;
}
#history-display.hidden {
  display: none;
}
.winning-number {
  list-style: none;
  margin-right: 15px;
}

#even-board {
  border-radius: 10px 10px 50px 10px;
  background: linear-gradient(270deg, rgb(0, 151, 0) 99%,rgb(0, 100, 0));
  color: rgb(214, 246, 215);

}
#odd-board {
  border-radius: 10px 10px 10px 50px;
  background: linear-gradient(270deg, rgb(0, 100, 0) , rgb(0, 151, 0) 1%);
  color: rgb(206, 255, 208);
}
#black-board {
  border-radius: 10px 50px 10px 10px;

}
#red-board {
  border-radius: 50px 10px 10px 10px;
}
.carousel-container {
  width: 50px; /* Adjust width as needed */
  height: 50px; /* Adjust height as needed */
  overflow: hidden;
  border: 1px solid #cccccc3c; /* Example border */
  background: linear-gradient(to right, rgba(255, 255, 255, 0.356), rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.356));
  color: rgba(0, 0, 0, 0.647);
  border-radius: 0 0 50px 50px;
}

.carousel {
  display: flex;
  flex-direction: column;
  transition: transform 2s ease; /* Example transition duration */
  transform: translateY(0); /* Initial transform to position first number */
}

.carousel-number {
  width: 100%;
  height: 50px; /* Adjust height as needed */
  line-height: 50px; /* Center vertically */
  text-align: center;
  font-size: 3rem; /* Adjust font size as needed */
  border-bottom: 5px solid rgba(72, 255, 0, 0.665); /* Example border */
}
#roll-indicator {
  margin: 0;
  border-bottom: none;
  background: linear-gradient(to right, rgba(255, 255, 255, 0.356), rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.356));
  transition: background-color 0.25s ease;
  border-radius:20px 20px 0 0;
  width: 95%; /* Adjust width as needed */
  height: 24px; /* Adjust height to match carousel-number */
  position: relative; /* Ensure z-index works */
  box-shadow: none;
}
#roll-indicator.rolling {
animation: rolling 1s infinite;
}
@keyframes rolling {
  0% {
    background: rgba(255, 255, 0, 0.476);
  }
  50% {
    background: rgba(255, 255, 162, 0.599);
  }
  100% {
    background: rgba(255, 255, 0, 0.476);
  }
}

#roll-indicator.active {
  background-color: rgb(255, 255, 255);
  animation: blink 0.5s ease infinite;
}
#winningNumber {
  border: 1px solid rgba(16, 101, 48, 0.359);
  margin-top: 15px;
  width: 250px;
  border-radius: 20px;
  display: flex;
  flex-direction: column;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  justify-content: center;
  align-items: center;
  background: linear-gradient(to right, #81f5815b, rgba(139, 243, 118, 0.5), rgba(124, 247, 140, 0.356));
}

@keyframes blink {
  0% {
    background-color: rgb(255, 255, 255);
  }
  50% {
    background-color: rgb(26, 255, 0);
  }
  100% {
    background-color: rgb(255, 255, 255);
  }
}


</style>
</head>
<body>
  <div id="lossParticles" class="hidden"></div>
  <div id="breakEven" class="hidden"></div>
  <h1 id="loseMessage"></h1>
  <h1 id="winMessage"></h1>
  <h1 id="breakEvenMessage"></h1>

  <header>
    <nav>
      <div id="account-container">
        <p id="account" class="board-text">ACCOUNT</p>
        <div id="wallet-status-container">
        <div id="log-status-indicator"></div>
        <div id="wallet-address">Disconnected</div>
        </div>
      </div>
    <button class="nav-button" id="account-button" disabled>Create Account</button>
    <button class="nav-button" id="connect-wallet-button">Connect Wallet</button>
      <div id="winningNumber" >
        <p class="board-text" id="roll-indicator"></p>
        <div class="carousel-container">
          <div class="carousel">
            <div class="carousel-number"></div>
            <div class="carousel-number">1</div>
            <div class="carousel-number">2</div>
            <div class="carousel-number">3</div>
            <div class="carousel-number">4</div>
            <div class="carousel-number">5</div>
            <div class="carousel-number">6</div>
          </div>
        </div>
    </div>
    <div id="stats-container">
      <div class="stat-item">
        <p class="board-text">TOTAL BET</p>
        <div class="board-value fade-in-out"" id="totalBetAmount"></div>
      </div>
      <div class="stat-item">
        <p class="board-text">ROUND</p>
        <p class="board-value" id="round"></p>
      </div>
      <div class="stat-item">
        <p class="board-text">BALANCE</p>
        <p class="board-value fade-in-out" id="balance"></p>
      </div>
      <div class="stat-item">
        <button class="nav-button" id="deposit-button">Deposit</button>
      </div>
<div id="totalPL"></div>
    </div>
    </nav>
  </header>
<div class="board-container">
  <div id="even-board" class="betting-board parity-streaks" data-value="8">Even</div>
  <div id="odd-board" class="betting-board parity-streaks" data-value="7">Odd</div>
  <div id="one-board" class="betting-board numbered-board number-streaks" data-value="1"></div>
  <div id="two-board" class="betting-board numbered-board number-streaks" data-value="2"></div>
  <div id="three-board" class="betting-board numbered-board number-streaks" data-value="3"></div>
  <div id="four-board" class="betting-board numbered-board number-streaks" data-value="4"></div>
  <div id="five-board" class="betting-board numbered-board number-streaks" data-value="5"></div>
  <div id="six-board" class="betting-board numbered-board number-streaks" data-value="6"></div>
  <div id="black-board" class="betting-board color-streaks" data-value="10">Black</div>
  <div id="red-board" class="betting-board color-streaks" data-value="9">Red</div>
</div>
<!-- <div id="winsDisplay">
  <div class="win-item">
    <div class="streaks" id="parity-streaks"></div>
    <div id="parity" class="lights">
      <div class="light">1x</div>
      <div class="light">1.5x</div>
      <div class="light">2x</div>
      <div class="light">2.5x</div>
      <div class="light">3x</div>
      <div class="light">4x</div>
      <div class="light">5x</div>
      <div class="light">6x</div>
    </div>
  </div>
  <div class="win-item">
    <div class="streaks" id="number-streaks"></div>
    <div id="number" class="lights">
      <div class="light">.1%</div>
      <div class="light">.5%</div>
      <div class="light">1%</div>
    </div>
  </div>
  <div class="win-item">
    <div class="streaks" id="color-streaks"></div>
    <div id="color" class="lights">
      <div class="light">1x</div>
      <div class="light">1.5x</div>
      <div class="light">2x</div>
      <div class="light">2.5x</div>
      <div class="light">3x</div>
      <div class="light">4x</div>
      <div class="light">5x</div>
      <div class="light">6x</div>
    </div>
  </div>
</div> -->
<div id="chips" class="chips-container">
</div>
<button class="nav-button" id="place-bet-button">Place Bet</button>
<!-- <button id="history-button">Get History</button> -->
<ul id="history-display" class="hidden"></ul>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@1.6.0/dist/web3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

<script type="module">

import { contractABI } from './abi.js';
import { contractAddress } from './address.js'; 

let web3;
let contract;
let userAccount;
let accountCreated = false;


const createAccountButton = document.getElementById("account-button");
const depositButton = document.getElementById("deposit-button");
const connectWalletButton = document.getElementById("connect-wallet-button");
const playButton = document.getElementById("place-bet-button");
const balance = document.getElementById("balance");
const round = document.getElementById("round");
const numberedBoards = document.querySelectorAll('.numbered-board');

const initialize = async () => {
  if (window.ethereum) {
    try {
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      userAccount = accounts[0];
      web3 = new Web3(window.ethereum);
      contract = new web3.eth.Contract(contractABI, contractAddress);
      connectWalletButton.disabled = true;
      const timestamp = new Date().toLocaleString();
      console.log(`Log in successful at ${timestamp}`);
      const accountConnectionIndicator = document.getElementById("log-status-indicator");
      accountConnectionIndicator.classList.add('logged-in');
      const rollIndicator = document.getElementById('roll-indicator');
      rollIndicator.classList.add('active');
      setTimeout(() => { rollIndicator.classList.remove('active') }, 2000);
      updateAccountDisplay();
      let totalBetAmount = calculateTotalBetAmount();
      updateBetDisplay(totalBetAmount);
      updateColorMapping();
      fetchAndUpdateConsecutiveWins();
      dealChips();
    } catch (error) {
      console.log(error);
      alert("There was an error connecting wallet");
    }
  } else {
    console.log("Failed to make request");
    alert("Failed to make request");
  }
};
connectWalletButton.addEventListener("click", initialize);
// Handles updating UI account wallet address display
const accountAddress = document.getElementById('wallet-address');
const updateAccountDisplay = async () => {
  try {
    const isAccountCreated = await contract.methods.getAccountStatus(userAccount).call({ from: userAccount });
    if(isAccountCreated) {
      const balanceValue = await contract.methods.getBalance().call({from: userAccount});
      const balanceInMatic = web3.utils.fromWei(balanceValue);
      const roundValue = await contract.methods.getCurrentRound().call({from: userAccount});
      depositButton.classList.add('active');
      createAccountButton.style.display = 'none';
      connectWalletButton.style.display = 'none';
      let sliceAmount = balanceInMatic > 0 && balanceInMatic < 10 ? 4 : balanceInMatic < 100 ? 5 : balanceInMatic < 1000 ? 6 : balanceInMatic < 10000 ? 7 : 0; 
      balance.textContent = balanceInMatic.slice(0, sliceAmount);
      if(balanceInMatic < 1) {
        depositButton.classList.add('broke');
      }
      round.textContent = roundValue;
      accountAddress.innerHTML = `<p>Connected!</p>`;
      setTimeout(() => {
        accountAddress.innerHTML = `<p>0x...${userAccount.slice(-5)}</p>`;
      }, 1500);
      console.log("Welcome back!");
    } else {
      createAccountButton.disabled = false;
      createAccountButton.classList.add('active');
      connectWalletButton.classList.add('hidden');
      console.log("Please create an account to play!");
    }
  } catch (error) {
    console.log(error);
  }
}
const accountContainer = document.getElementById('wallet-status-container');
accountContainer.addEventListener("mouseenter", () => {
  if (userAccount) {
    accountAddress.innerHTML = `<p>${userAccount}</p>`;
  }
});
accountContainer.addEventListener("mouseleave", () => {
  if (userAccount) {
    accountAddress.innerHTML = `<p>0x...${userAccount.slice(-5)}</p>`;
  }
});
// Handles updating the UI bet section including the balance and total bet
const fetchBalance = async () => {
  try {
    const balanceValue = await contract.methods.getBalance().call({ from: userAccount });
    const balanceValueInMatic = web3.utils.fromWei(balanceValue);
    return parseFloat(balanceValueInMatic); // Convert to a float for numerical operations
  } catch (error) {
    console.error("Error updating balance:", error);
    return null;
  }
};
const updateBetDisplay = async (totalBetAmount) => {
  try {
    let currentBalance = await fetchBalance();
    let betAmountInMatic = web3.utils.fromWei(totalBetAmount.toString());
    if (currentBalance !== null) {
      let remainingBalance = currentBalance - betAmountInMatic; // Ensure totalBetAmount is parsed as float
      const balanceElement = document.getElementById('balance'); // Assuming 'balance' is the ID of your balance display element
      if (balanceElement) {
        balanceElement.textContent = remainingBalance.toFixed(2); // Display balance rounded to 2 decimal places
      }
      const totalBetElement = document.getElementById('totalBetAmount');
      if (totalBetElement) {
        totalBetElement.classList.add('hidden2'); // Start fade out animation
        balance.classList.add('hidden3');

        // Wait for the fade out to complete before updating the value and fading in
        setTimeout(() => {
          let stringValue =  web3.utils.fromWei(totalBetAmount.toString(), 'ether');
          let splicedValue = stringValue.slice(1);
          if(stringValue  == 0) {
            totalBetElement.textContent = `${stringValue}`
          } else if (stringValue >= 0 && stringValue < 1) {
            totalBetElement.textContent = `${splicedValue}`;
          } else if (stringValue >= 1) {
            totalBetElement.textContent = `${stringValue}`;
          }
          totalBetElement.classList.remove('hidden2'); // Start fade in animation
          balance.classList.remove('hidden3');
        }, 150); // Match this duration with the CSS transition duration
      }
    } else {
      console.error("Failed to fetch current balance.");
    }
  } catch (error) {
    console.error("Error displaying total bet amount:", error);
  }
};
// Handles updating the color assignment for each numbered board
const fetchColorMapping = async () => {
    try {
        const result = await contract.methods.getColorMapping().call();
        return result; // Returns uint8[6] array
    } catch (error) {
        console.error("Error fetching color mapping:", error);
        return null;
    }
}
const updateColorMapping = async () => {
    const colorMapping = await fetchColorMapping();
    if (!colorMapping) {
        console.log("Error: Failed to fetch color mapping from contract");
        return;
    }
    let colors = { red: 0, black: 0 };
    numberedBoards.forEach((board, index) => {
        const color = colorMapping[index] == 1 ? 'red' : 'black';
        board.classList.remove('red', 'black'); 
        board.classList.add('waiting');
        setTimeout(() => {
          board.classList.remove('waiting');
          board.classList.add(color);
          colors[color]++;
          console.log("Index " + index + " with value " + colorMapping[index] + ", color applied: " + color);
        }, 3000)
    });
    console.log("Colors assigned:", colors);
}
// Handles displaying multiplier for the board
const fetchAndUpdateConsecutiveWins = async () => {
    try {
        // Call the getConsecutiveWins function from your contract
        const result = await contract.methods.getConsecutiveWins().call({from: userAccount});

        // Update the UI based on the result
        console.log(result);
        // updateLights('number', result[0]);
        updateBoardMultiplier('.number-streaks',result[0]);
        // updateLights('parity', result[1]);
        updateBoardMultiplier('.parity-streaks',result[1]);
        // updateLights('color', result[2]);  
        updateBoardMultiplier('.color-streaks',result[2]);

    } catch (error) {
        console.error('Error fetching consecutive wins:', error);
    }
}
const updateBoardMultiplier = (elementclass,multipliedAmount) => {
  const boardToChange = document.querySelectorAll(`${elementclass}`);
  if(elementclass == '.parity-streaks' || elementclass == '.color-streaks') {
    multipliedAmount = multipliedAmount == 1 ? multipliedAmount : multipliedAmount == 2 ? 1.5 : multipliedAmount == 3 ? 2 : multipliedAmount == 4 ? 2.5 : multipliedAmount == 5 ? 3 : multipliedAmount == 6 ? 4 : multipliedAmount == 7 ? 5 : multipliedAmount == 8 ? 6 : '';
  }
  boardToChange.forEach(board => {
    const previousWinMultiplier = board.querySelector('.win-multiplier');
    if (previousWinMultiplier) {
      board.removeChild(previousWinMultiplier);
    }
    if(multipliedAmount > 1){
      if(elementclass == '.parity-streaks') {
        const element = document.createElement('div');
        element.classList.add('win-multiplier');
        element.style.color = 'white';
        element.textContent =  `${multipliedAmount}x`;
        board.appendChild(element);
      } else if(elementclass == '.number-streaks') {
        const element = document.createElement('div');
        element.classList.add('win-multiplier');
        element.style.color = 'white';
        element.style.position = 'absolute';
        element.style.top = '25%';
        if(multipliedAmount > 2 ) {        element.textContent =  `${multipliedAmount == 3 ? .1 : multipliedAmount == 4 ? .5 : multipliedAmount == 5 ? .5 : multipliedAmount == 6 ? 1 : ''}%`;}
        board.appendChild(element);

      } else if( elementclass == '.color-streaks') {
        const element = document.createElement('div');
        element.classList.add('win-multiplier');
        element.style.color = 'white';
        element.textContent =  `${multipliedAmount}x`;
        board.appendChild(element);
      }
    }
  })
}
// Handles generating chips based on user  balance
const dealChips = async () => {
  const chipsContainer = document.getElementById('chips');
  const chipValues = [0.1, 0.25, 0.5, 1]; // Define your chip values in descending order

  try {
    const balanceValue = await contract.methods.getBalance().call({ from: userAccount });
    const balanceInMatic = web3.utils.fromWei(balanceValue);

    let remainingBalance = balanceInMatic;

    for (let i = 0; i < chipValues.length; i++) {
      const value = chipValues[i];

      if (remainingBalance >= value) {
        const chip = document.createElement('div');
        chip.className = 'chip';
        chip.setAttribute('draggable', 'true');
        chip.setAttribute('data-value', value);

        chip.innerHTML = `
          <div class="center-circle"></div>
          <div class="center-circle value">${value}</div>
        `;
        // Assign colors and styles based on chip value
        switch (value) {
          case 0.1:
            chip.classList.add('chip-0_1');
            break;
          case 0.25:
            chip.classList.add('chip-0_25');
            break;
          case 0.5:
            chip.classList.add('chip-0_5');
            break;
          case 1:
            chip.classList.add('chip-1');
            break;
          default:
            chip.classList.add('chip-default');
            break;
        }
        chip.addEventListener('dragstart', dragStart);
        chip.addEventListener('dragend', dragEnd);
        chipsContainer.appendChild(chip);
        remainingBalance -= value; 
      } else {
        break;
      }
    }
  } catch (error) {
    console.log(error);
  }
}
// Handles deposits for player
const deposit = async () => {
  try {
    const amount = prompt("Please enter an amount in MATIC");
    if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
      const amountInWei = web3.utils.toWei(amount, "ether");
      const receipt = await contract.methods.deposit().send({ from: userAccount, value: amountInWei });
      console.log("Successfully deposited " + amount + " MATIC");
      alert("Successfully deposited " + amount + " MATIC");
      updateStats(); // Update stats and regenerate chips
      receipt.events.DepositComplete ? 
        console.log("Event: ", receipt.events.DepositComplete.returnValues) :
        console.log("Event not found in receipt");
    } else {
      console.log("Please enter a valid amount");
      alert("Please enter a valid amount");
    }
  } catch (error) {
    console.log("Could not make deposit request: " + error);
    alert("Could not make deposit request: " + error);
  }
};
depositButton.addEventListener("click", deposit);
// Handles creation of an account for player
const createAccount = async () => {
      try {
        await contract.methods.createAccount().send({ from: userAccount });
        console.log("Account created successfully.");
        updateStats();
      } catch (error) {
        console.log("Error creating your account. " + error);
      }
    };
createAccountButton.addEventListener("click", createAccount);
// Handles bets for the player
const bets = [];
const play = async () => {
  const rollIndicator = document.getElementById('roll-indicator');
rollIndicator.classList.add('rolling');
  try {
    let totalBetAmounts = calculateTotalBetAmount();
    let totalProfitForRound = 0;
    let netProfitForRound = 0;

    console.log("Total bet amounts " + totalBetAmounts);

    if (!web3 || !userAccount || !contract) {
      throw new Error("Web3, user account, or contract not initialized.");
    }

    if (bets.length === 0) {
      throw new Error("No bets to place.");
    }

    console.log("Sending bet transaction...");
    const receipt = await contract.methods.play(bets).send({ from: userAccount });
    console.log("Bets placed successfully");
    console.log(receipt);

    if (receipt.events && receipt.events.Result) {
      rollIndicator.classList.remove('rolling');
      rollIndicator.classList.add('active');
      if (Array.isArray(receipt.events.Result)) {
       let target = rollAnimation(receipt.events.Result[0].returnValues[3]);
        unRollAnimation(target);
        receipt.events.Result.forEach((event) => {
          const returns = event.returnValues;
          console.log(`Winning number: ${returns[3]}`);
          totalProfitForRound += parseFloat(web3.utils.fromWei(returns[5]));

          // Check if receipt.events.FeeDistributed exists and is an array
          if (receipt.events.FeeDistributed && Array.isArray(receipt.events.FeeDistributed)) {
            const feeEvent = receipt.events.FeeDistributed.find((feeEvent) => feeEvent.blockNumber === event.blockNumber);
            if (feeEvent) {
              const feeReturns = feeEvent.returnValues;
              const unixTimestamp = parseInt(feeReturns[1]) * 1000;
              const date = new Date(unixTimestamp);
              const formattedDate = date.toLocaleString();
              const amountInMatic = web3.utils.fromWei(feeReturns[0]);
              console.log(`Fee distributed at ${formattedDate} for amount of ${amountInMatic} MATIC`);
            }
          }
        });
      } else {
        const returns = receipt.events.Result.returnValues;
        console.log(`Winning number: ${returns[3]}`);
        let target = rollAnimation(returns[3]);
        unRollAnimation(target);
        totalProfitForRound += parseFloat(web3.utils.fromWei(returns[5]));

        // Check if receipt.events.FeeDistributed exists and is an array
        if (receipt.events.FeeDistributed && Array.isArray(receipt.events.FeeDistributed)) {
          const feeEvent = receipt.events.FeeDistributed.find((feeEvent) => feeEvent.blockNumber === receipt.events.Result.blockNumber);
          if (feeEvent) {
            const feeReturns = feeEvent.returnValues;
            const unixTimestamp = parseInt(feeReturns[1]) * 1000;
            const date = new Date(unixTimestamp);
            const formattedDate = date.toLocaleString();
            const amountInMatic = web3.utils.fromWei(feeReturns[0]);
          }
        }
      }

      let totalBetAmountsInMatic = parseFloat(web3.utils.fromWei(totalBetAmounts.toString()));

      if (totalBetAmountsInMatic > totalProfitForRound) {
        netProfitForRound = totalBetAmountsInMatic - totalProfitForRound;

        setTimeout(() => { lossAnimation(netProfitForRound)}, 5500);
      } else if (totalBetAmountsInMatic < totalProfitForRound) {
        netProfitForRound = totalProfitForRound - totalBetAmountsInMatic;
        setTimeout(() => {winAnimation(netProfitForRound)}, 5550);
      } else {
        setTimeout(() => {breakEvenAnimation()}, 5550);
      }

    } else {
      console.log("No Result event found in the receipt.");
      throw new Error("No Result event found in the receipt.");
    }
    // Remove chips from the DOM
    setTimeout(() => {
      const boards = document.querySelectorAll('.betting-board');
    boards.forEach(board => {
      const chips = board.querySelectorAll('.placed');
      chips.forEach(chip => chip.remove());
    });

    }, 10000);
    bets.length = 0;
    let updatedTotalBetAmount = calculateTotalBetAmount();
    let updatedTotalBetAmountInMatic = parseFloat(web3.utils.fromWei(updatedTotalBetAmount.toString()));
    setTimeout(() => {
      updateStats();
      updateBetDisplay(updatedTotalBetAmountInMatic);
      updateColorMapping();
      fetchAndUpdateConsecutiveWins();
    }, 8500);
  } catch (error) {
    console.error("Error placing bets:", error);
    alert("Error placing bets: " + error.message);
    rollIndicator.classList.remove('rolling');
    // Remove chips from the DOM
    const boards = document.querySelectorAll('.betting-board');
    boards.forEach(board => {
      const chips = board.querySelectorAll('.placed');
      chips.forEach(chip => chip.remove());
    });
    bets.length = 0;
    updateStats();
    setTimeout(() => {
      totalBetAmount.textContent = 0;
    }, 150);
  }
};
playButton.addEventListener("click", play);
// Handles update the UI stats 
const updateStats = async () => {
  try {
    const balanceValue = await contract.methods.getBalance().call({ from: userAccount });
    const balanceInMatic = web3.utils.fromWei(balanceValue);
    const roundValue = await contract.methods.getCurrentRound().call({ from: userAccount });
    let sliceAmount = balanceInMatic > 0 && balanceInMatic < 10 ? 4 : balanceInMatic < 100 ? 5 : balanceInMatic < 1000 ? 6 : balanceInMatic < 10000 ? 7 : 0; 
    balance.textContent = balanceInMatic.slice(0, sliceAmount);
    removeExistingChips();
    dealChips(parseFloat(balanceInMatic));
    if (balanceInMatic < 1) {
      depositButton.classList.add('broke');
    } else {
      depositButton.classList.remove('broke');
    }
    round.textContent = roundValue;
  } catch (error) {
    console.log("error updating stats " + error);
  }
};
const removeExistingChips = () => {
  const chipsContainer = document.getElementById('chips');
  while (chipsContainer.firstChild) {
    chipsContainer.removeChild(chipsContainer.firstChild);
  }
};
// CHIP FUNCTIONALITY
const chips = document.querySelectorAll('.chip');
chips.forEach(chip => {
  chip.addEventListener('dragstart', dragStart);
  chip.addEventListener('dragend', dragEnd);
});
function dragStart() {
  this.classList.add('dragging');
  const chipValue = parseFloat(this.getAttribute('data-value'));
  const remainingBalance = parseFloat(balance.textContent);
  if (chipValue > remainingBalance) {
    console.log(`Chip value ${chipValue} exceeds remaining balance ${remainingBalance}. Disabling chip.`);
    // Disable the chip
    this.classList.add('disabled');
    this.setAttribute('draggable', 'false'); // Disable dragging
    this.removeEventListener('dragstart', dragStart); // Remove dragstart listener
    this.removeEventListener('dragend', dragEnd); // Remove dragend listener
    // Store the chip value when disabling it
    this.dataset.disabledValue = chipValue;
    this.classList.remove('dragging');
    return; // Exit early if chip value exceeds balance
  }
}
function dragEnd() {
  this.classList.remove('dragging');
}
const removeChip = (parentChip, chip, value, boardValue) => {
  // Calculate remaining balance after removing the chip
  const remainingBalance = parseFloat(balance.textContent) + parseFloat(chip.getAttribute('data-value'));
  // Enable chips if balance allows
  document.querySelectorAll('.disabled').forEach(disabledChip => {
    const chipValue = parseFloat(disabledChip.getAttribute('data-value'));
    if (remainingBalance >= chipValue) {
      disabledChip.classList.remove('disabled');
      disabledChip.setAttribute('draggable', 'true');
      disabledChip.addEventListener('dragstart', dragStart);
      disabledChip.addEventListener('dragend', dragEnd);
      console.log(`Chip with a value of ${chipValue} has been enabled.`);
    }
  });
  chip.remove();
  decreaseAnimation();
  // Convert value to Wei
  const valueInWei = web3.utils.toWei(value.toString(), 'ether');
  const guess = parseInt(boardValue <= 6 ? boardValue : boardValue == 7 ? 1 : boardValue == 8 ? 2 : boardValue == 9 ? 1 : 2);
  // Remove the bet from the bets array
  const index = bets.findIndex(bet => bet.amount == valueInWei && bet.guess == guess);
  if (index !== -1) {
    bets.splice(index, 1);
    console.log(`${value} removed from ${boardValue}`);
    console.log(`Number of remaining bets: ${bets.length}`);
    bets.forEach(bet => console.log(bet)); // Log remaining bets for debugging
  } else {
    console.log(`No matching bet found for removal: ${valueInWei}, ${boardValue}`);
  }
  balance.textContent = `${remainingBalance}`;
  updateBetDisplay(calculateTotalBetAmount());
};

// BOARD FUNCTIONALITY
const boards = document.querySelectorAll('.betting-board');
boards.forEach(board => {
  board.addEventListener('dragover', dragOver);
  board.addEventListener('dragenter', dragEnter);
  board.addEventListener('dragleave', dragLeave);
  board.addEventListener('drop', dragDrop);
});
function dragOver(e) {
  e.preventDefault();
}
function dragEnter(e) {
  e.preventDefault();
  this.classList.add('hovered');
}
function dragLeave() {
  this.classList.remove('hovered');
}
function dragDrop(e) {
  e.preventDefault();
  this.classList.remove('hovered');
  if(bets.length >= 10) {
    alert("Maximum ten bets allowed.");
    return 1;
  }
  const chip = document.querySelector('.dragging');
  if (chip) {
    const boardValue = parseInt(this.getAttribute('data-value'));
    const chipValue = parseFloat(chip.getAttribute('data-value'));
    // Calculate absolute position for new chip
    const rect = this.getBoundingClientRect(); // Get position of the target element
    const offsetX = e.clientX - rect.left; // Calculate X position relative to target
    const offsetY = e.clientY - rect.top;  // Calculate Y position relative to target
    // Check if dropping this chip will exceed the current balance
    const remainingBalance = parseFloat(balance.textContent);
    const newChip = chip.cloneNode(true);
    newChip.classList.remove('dragging');
    newChip.classList.add('placed');
    newChip.style.position = 'absolute';
    newChip.style.top = `${offsetY}px`;
    newChip.style.left = `${offsetX}px`;
    setTimeout(() => {
       // Generate a random rotation angle (example: 0, 45, or 90 degrees)
      const randomAngle = Math.floor(Math.random() * 3) * 45; // Generates 0, 45, or 90
      // Apply the random keyframes animation to your element
      newChip.style.animation = `rotate-${randomAngle} .2s ease-in-out forwards`;
    }, 332)
    // Generate a random rotation angle (example: 0, 45, or 90 degrees)
    // Remove draggable attribute and add click event listener to remove the chip
    newChip.removeAttribute('draggable');
    newChip.addEventListener('click', () => {
      removeChip(chip,newChip, chipValue, boardValue);
    });
    // Append the chip to the drop target (this)
    this.appendChild(newChip);
    // Add bet information to your bets array
    let betType = boardValue < 7 ? 0 : boardValue < 9 ? 1 : 2;
    const colorBet = this.classList.contains('black') ? 2 : 1;
    let valueInWei = web3.utils.toWei(chipValue.toString(), 'ether');
    let stringWei = valueInWei.toString();
    const newBetObj = {
      amount: stringWei,
      betType,
      guess: boardValue <= 6 ? boardValue : boardValue === 7 ? 1 : boardValue === 8 ? 2 : boardValue === 9 ? 1 : 2
    };
    bets.push(newBetObj);
    console.log(`${stringWei} matic placed on ${boardValue <= 6 ? boardValue : boardValue === 7 ? 'odd' : boardValue === 8 ? 'even' : boardValue === 9 ? 'red' : 'black'} with bet type ${betType == 0 ? 'number' : betType == 1 ? 'parity' : 'color'}`);
    // Calculate and display total bet amount
    let totalBetAmount = calculateTotalBetAmount();
    updateBetDisplay(totalBetAmount);
    increaseAnimation();
    // Log the number of bets for debugging purposes
    console.log(`Number of bets: ${bets.length}`);
  }
}
const calculateTotalBetAmount = () => {
  return bets.reduce((total, bet) => total.add(web3.utils.toBN(bet.amount)), web3.utils.toBN('0'));
};
// ANIMATIONS
const winAnimation = (amountWon) => {
  const rollIndicator = document.getElementById('roll-indicator');
  rollIndicator.classList.remove('active');
  var duration = 2 * 1000;
  var end = Date.now() + duration;
  let winMessage =  document.getElementById('winMessage')
  winMessage.textContent = `WINNER! +${amountWon.toFixed(2)} MATIC`;
  winMessage.classList.add('show');
  setTimeout(() => {
    document.getElementById('winMessage').classList.remove('show');
  }, 2000);
  // Randomly generate confetti with various colors and angles
  (function frame() {
    confetti({
      particleCount: 5,
      angle: 60,
      spread: 55,
      origin: { x: 0 }
    });
    confetti({
      particleCount: 5,
      angle: 120,
      spread: 55,
      origin: { x: 1 }
    });

    if (Date.now() < end) {
      requestAnimationFrame(frame);
    }
  }());
}
const lossAnimation = (amountLost) => {
  const rollIndicator = document.getElementById('roll-indicator');
  rollIndicator.classList.remove('active');
  document.getElementById('lossParticles').classList.remove('hidden');
  let lossMessage = document.getElementById('loseMessage');
  lossMessage.textContent = `YOU LOSE -${amountLost.toFixed(2)} MATIC`;
  lossMessage.classList.add('show');
  particlesJS('lossParticles', {
    particles: {
      number: { value: 50 },
      color: { value: '#ff0000' }, // Red color for particles
      shape: {
        type: 'circle', // Use circles instead of an image
      },
      opacity: { value: 0.8 },
      size: { value: 10, random: true },
      move: {
        direction: 'bottom', // Move particles downwards
        speed: 5,
        out_mode: 'out', // Remove particles when they go out of canvas
      },
      line_linked: { enable: false }, // No links between particles
    },
    interactivity: {
      detect_on: 'canvas',
      events: {
        onhover: { enable: false },
        onclick: { enable: false },
      },
    },
    retina_detect: true,
  });
  // Hide particles and message after animation
  setTimeout(() => {
    document.getElementById('lossParticles').classList.add('hidden');
    lossMessage.classList.remove('show');
  }, 2000); // Duration of the particle effect and message
}
const breakEvenAnimation = () => {
  const rollIndicator = document.getElementById('roll-indicator');
  rollIndicator.classList.remove('active');
  document.getElementById('breakEven').classList.remove('hidden');
  let lossMessage = document.getElementById('breakEvenMessage');
  lossMessage.textContent = `Break Even`;
  lossMessage.classList.add('show');
  particlesJS('breakEven', {
    particles: {
      number: { value: 50 },
      color: { value: '#ffffff' }, // Red color for particles
      shape: {
        type: 'circle', // Use circles instead of an image
      },
      opacity: { value: 0.8 },
      size: { value: 10, random: true },
      move: {
        direction: 'none', // Move particles downwards
        speed: 5,
        random: true,
        out_mode: 'out', // Remove particles when they go out of canvas
      },
      line_linked: { enable: false }, // No links between particles
    },
    interactivity: {
      detect_on: 'canvas',
      events: {
        onhover: { enable: false },
        onclick: { enable: false },
      },
    },
    retina_detect: true,
  });
  setTimeout(() => {
    document.getElementById('breakEven').classList.add('hidden');
    lossMessage.classList.remove('show');
  }, 2000);
}
const rollAnimation = (winningNumber) =>  {
  const bettingBoard = document.querySelectorAll('.betting-board');
  const numberedBoards = document.querySelectorAll('.numbered-board');
  const carousel = document.querySelector('.carousel');
  const carouselHeight = 55; // Adjust to match your .carousel-number height
  const targetOffset = -(winningNumber) * carouselHeight; // Calculate offset based on winningNumber
  // Animate the carousel to the target number
  carousel.style.transform = `translateY(${targetOffset}px)`;
  setTimeout(() => {
    numberedBoards.forEach(board => {
      if (board.getAttribute('data-value') === winningNumber) {
        if(board.classList.contains('red')){
          bettingBoard[9].style.boxShadow = '1px 1px 1px 5px gold';
        } else if(board.classList.contains('black')) {
          bettingBoard[8].style.boxShadow = '1px 1px 1px 5px gold';
        }
        if(winningNumber % 2 == 0 ) {
          bettingBoard[0].style.boxShadow = '1px 1px 1px 5px gold';
        } else if (winningNumber % 2 !== 0) {
          bettingBoard[1].style.boxShadow = '1px 1px 1px 5px gold';
        }
      board.classList.add('active');
    }
          })
  }, 2500)
  return targetOffset;
}
const unRollAnimation = (target) =>  {
  const bettingBoard = document.querySelectorAll('.betting-board');
  const numberedBoards = document.querySelectorAll('.numbered-board');
  const carousel = document.querySelector('.carousel');
  console.log("Unroll started.");
  setTimeout(() => {
    numberedBoards.forEach(board => {
      board.classList.remove('active');
          })
          bettingBoard.forEach(board => {
            board.classList.remove('active');
            board.style.boxShadow = '';
          })
    carousel.style.transform = `translateY(0)`; 
    console.log("Unroll complete.");
  }, 10000);
}
const increaseAnimation = () => {
  const totalBetAmount = document.getElementById('totalBetAmount');
  const balance = document.getElementById('balance'); 
  totalBetAmount.classList.add('increase');
  balance.classList.add('decrease');
    setTimeout(() => {
      totalBetAmount.classList.remove('increase');
      balance.classList.remove('decrease');
    }, 250)
}
const decreaseAnimation = () => {
  const totalBetAmount = document.getElementById('totalBetAmount');
  const balance = document.getElementById('balance'); 
  totalBetAmount.classList.add('decrease');
  balance.classList.add('increase');
    setTimeout(() => {
      totalBetAmount.classList.remove('decrease');
      balance.classList.remove('increase');
    }, 250)
}
// Huge problem in fetching number history for the first round of ebery batch... it shows the second rounds number 
</script>
</body>
</html>
